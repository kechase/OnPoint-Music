### This script is used to download files from the database to a csv file. 
import os
import csv
import firebase_admin
from firebase_admin import credentials
from firebase_admin import firestore
import json

# Initialize Firebase Admin SDK
cred = credentials.Certificate("/Users/katie/Documents/workspace/z-Security-Keys/onpoint-music-security-key.json")
firebase_admin.initialize_app(cred)
db = firestore.client()

# Enter security key generated by firebase into the credentials.Certificate (or for higher security, follow recommendation below)

## Recommendation: in your home directory utilize a file such as .zprofile to store the environment variable that links to your security key. That way a physical link doesn't have to be entered and is less likely to break. This is how the code above is currently structured, to reference the env variable. Instructions on how to do that here: (https://firebase.google.com/docs/admin/setup/#initialize_the_sdk_in_non-google_environments) 
        
# Helper function for reading subject data from database
def subjcsvread(subjects, csvFileName, db, collection):
    # Parameter validation
    if not subjects:
        print("Warning: Empty subjects list provided. No data will be retrieved.")
        return []
    
    if not collection:
        print("Error: No collection specified.")
        return []
        
    if not db:
        print("Error: Database client not provided.")
        return []
    
    subjectList = []
    for subj in subjects:

        try:
            docs = db.collection(collection).where(u'id', u'==', subj).stream()
            doc_found = False
            for doc in docs:
                doc_found = True
                fields = doc.to_dict()
            # Extract fields from the document
                info = (fields.get('id'), 
                        fields.get('age'), 
                        fields.get('comments'), 
                        fields.get('distractions'),
                        fields.get('distracto'),
                        fields.get('handedness'), 
                        fields.get('ethnicity'), 
                        fields.get('language_count'),
                        fields.get('mouse_type'), 
                        fields.get('music_instrument'),
                        fields.get('music_practice'),
                        fields.get('music_experience'),
                        fields.get('race'), 
                        fields.get('returner'), 
                        fields.get('gender'), 
                        fields.get('tgt_file'),
                        fields.get('condition')
                    )
                subjectList.append(info)
            if not doc_found:
                print(f"Warning: No documents found for subject {subj} in collection '{collection}'")
        except firestore.exceptions.NotFound as e:
            print(f"Collection not found error for subject '{subj}': {e}")
        except firestore.exceptions.InvalidArgument as e:
            print(f"Invalid query argument for subject '{subj}': {e}")
        except Exception as e:
            print(f"Unexpected error processing subject '{subj}': {str(e)}")
            continue

    return subjectList


def getSubjectData(subjects, csvFileName, db, collection):
    subjectList = subjcsvread(subjects, csvFileName, db, collection)

    # Create CSV file and write inside the context manager
    with open(csvFileName, 'w', newline='') as file:
        writer = csv.writer(file)
        header = ('subject_id', 'age', 'comments', 'distractions', 'distracto','handedness', 
                  'ethnicity', 'language_count', 'mouse_type', 'music_instrument', 
                  'music_practice', 'music_experience', 'race', 'returner', 'gender', 
                  'target_file', 'condition')
        writer.writerow(header)
        writer.writerows(subjectList)

    print(f"Subject data saved to {csvFileName}")
 
# Helper function for reading trial data from database
def trialcsvread(collection, numTrials, csvFileName, subjects, db):   
    trials = []

    # Parameter validation
    if not subjects:
        print("Warning: Empty subjects list provided. No data will be retrieved.")
        return trials
        
    if not collection:
        print("Error: No collection specified.")
        return trials
    
    for trialID in subjects:
        try:
            # First try to find documents by 'id' field
            docs = list(db.collection(collection).where(u'id', u'==', trialID).stream())
            
            # If no documents found, try using the document ID directly
            if not docs:
                doc_ref = db.collection(collection).document(trialID)
                doc = doc_ref.get()
                if doc.exists:
                    docs = [doc]
            
            if not docs:
                print(f"Warning: No documents found for subject '{trialID}' in collection '{collection}'")
                continue
                
            for doc in docs:
                fields = doc.to_dict()
                print(f"Processing trial data for: {trialID}, doc ID: {doc.id}")
                
                # **DEBUG: Print all available fields to see what's actually saved**
                print("Available fields in document:")
                for key in sorted(fields.keys()):
                    if isinstance(fields[key], list):
                        print(f"  {key}: [list with {len(fields[key])} items]")
                    else:
                        print(f"  {key}: {fields[key]}")
                
                # Check if data uses flattened hand path format
                is_flattened = fields.get('hand_path_flattened', False)
                print(f"Hand path flattened: {is_flattened}")
                
                # Get basic fields - all snake_case
                exp_ID = fields.get('experiment_id', 'Unknown')
                name = fields.get('id', doc.id)
                group = fields.get('group_type', 'Unknown')

                # Check if required arrays exist
                required_arrays = ['currentDate', 'trialNum', 'target_angle', 'trial_type', 
                                  'rt', 'hand_fb_angle', 'rotation', 'mt', 'search_time', 'reach_feedback']
                
                missing = [field for field in required_arrays if field not in fields or not fields.get(field)]
                if missing:
                    print(f"Warning: Missing required fields for {trialID}: {missing}")
                    # **DON'T SKIP - try to continue with available data**
                    print("Continuing with available fields...")
                
                # Get basic fields
                exp_ID = fields.get('experimentID', 'Unknown')
                name = fields.get('id', doc.id)  # Use doc ID as fallback
                group = fields.get('group_type', 'Unknown')
              # Get array fields - all snake_case
                curr_date_arr = fields.get('current_date', [])
                trial_num_arr = fields.get('trial_num', [])
                tgt_ang_arr = fields.get('target_angle', [])
                trial_type_arr = fields.get('trial_type', [])
                rot_arr = fields.get('rotation', [])
                hand_ang_arr = fields.get('hand_fb_angle', [])
                rt_arr = fields.get('reaction_time', [])    # snake_case
                mt_arr = fields.get('movement_time', [])    # snake_case
                search_arr = fields.get('search_time', [])
                reach_fb_arr = fields.get('reach_feedback', [])
                
                print(f"Array lengths:")
                print(f"  current_date: {len(curr_date_arr)}")
                print(f"  trial_num: {len(trial_num_arr)}")
                print(f"  target_angle: {len(tgt_ang_arr)}")
                print(f"  reaction_time: {len(rt_arr)}")
                print(f"  movement_time: {len(mt_arr)}")

                # Optional fields
                start_x = fields.get('start_x', [None] * len(curr_date_arr))
                start_y = fields.get('start_y', [None] * len(curr_date_arr))
                screen_height = fields.get('screen_height', [None] * len(curr_date_arr))
                screen_width = fields.get('screen_width', [None] * len(curr_date_arr))
                
                # Handle hand path data
                hand_path_by_trial = {}
                
                if is_flattened:
                    for key, value in fields.items():
                        if key.startswith('trial_') and ('_count' in key or '_first_' in key or '_last_' in key or '_sample_' in key):
                            parts = key.split('_')
                            if len(parts) >= 2 and parts[1].isdigit():
                                trial_num = int(parts[1])
                                
                                if trial_num not in hand_path_by_trial:
                                    hand_path_by_trial[trial_num] = {}
                                
                                field_name = '_'.join(parts[2:]) if len(parts) > 2 else 'unknown'
                                hand_path_by_trial[trial_num][field_name] = value
                
                # Find minimum length across all arrays
                all_arrays = [curr_date_arr, trial_num_arr, tgt_ang_arr, trial_type_arr, 
                             rot_arr, hand_ang_arr, rt_arr, mt_arr, search_arr, reach_fb_arr]
                non_empty_arrays = [arr for arr in all_arrays if len(arr) > 0]
                
                if not non_empty_arrays:
                    print(f"No trial data arrays found for {trialID}")
                    continue
                
                min_len = min(len(arr) for arr in non_empty_arrays)
                print(f"Processing {min_len} trials for {trialID}")
                
                for i in range(min_len):
                    # Safe array access
                    def safe_get(arr, idx, default=""):
                        return arr[idx] if idx < len(arr) and arr else default
                    
                    trial_num = safe_get(trial_num_arr, i, i + 1)
                    
                    # Get hand path data for this trial
                    hand_path_data = hand_path_by_trial.get(trial_num, {})
                    hand_path_json = ""
                    if hand_path_data:
                        try:
                            hand_path_json = json.dumps(hand_path_data)
                        except Exception as e:
                            print(f"Error converting hand path data: {str(e)}")
                    
                    # Safe access for optional fields
                    start_x_val = start_x[i] if i < len(start_x) else None
                    start_y_val = start_y[i] if i < len(start_y) else None
                    screen_height_val = screen_height[i] if i < len(screen_height) else None
                    screen_width_val = screen_width[i] if i < len(screen_width) else None
                    
                    # Create trial record
                    trial = (
                        exp_ID, name, 
                        safe_get(curr_date_arr, i), 
                        safe_get(trial_num_arr, i, i + 1), 
                        safe_get(tgt_ang_arr, i), 
                        safe_get(trial_type_arr, i), 
                        safe_get(rot_arr, i), 
                        safe_get(hand_ang_arr, i), 
                        safe_get(rt_arr, i), 
                        safe_get(mt_arr, i), 
                        safe_get(search_arr, i), 
                        safe_get(reach_fb_arr, i), 
                        hand_path_json, 
                        start_x_val, start_y_val, 
                        screen_height_val, screen_width_val, group
                    )
                    trials.append(trial)
                
                print(f"Added {min_len} trials for {trialID}")
                
        except Exception as e:
            print(f"Error processing {trialID}: {str(e)}")
            continue
    
    print(f"Total trials collected: {len(trials)}")
    return trials

def getTrialData(collection, numTrials, csvFileName, subjects, db):
    if not collection or not subjects or not csvFileName or not db:
        print("Error: Missing required parameters")
        return
        
    if numTrials <= 0:
        numTrials = 100

    trials = trialcsvread(collection, numTrials, csvFileName, subjects, db)
    
    # Create CSV file
    with open(csvFileName, 'w', newline='') as file:
        writer = csv.writer(file)
        # Consistent snake_case headers
        header = ('experiment_name', 'subject_id', 'start_time', 'trial_number', 'target_angle', 
                  'cursor_fb', 'rotation', 'hand_angle', 'reaction_time', 'movement_time', 
                  'search_time', 'reach_feedback', 'hand_path', 'start_x', 'start_y', 
                  'screen_height', 'screen_width', 'group')
        writer.writerow(header)
        writer.writerows(trials)
    
    print(f"Trial data saved to {csvFileName}")

def addTrialData(collection, numTrials, csvFileName, subjects, db):
    trials = trialcsvread(collection, numTrials, csvFileName, subjects, db)
    
    with open(csvFileName, 'a', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(trials)

# Download subject and trial data

## Get subject data
# Update test participant ID
subjects = ['katie']  
# Update filepath with participant ID
getSubjectData(subjects, '/Users/katie/Documents/1-Product/Research/OnPoint-Music-Admin-and-Data/data_storage/subjects_raw/katie.csv', db, 'Subjects')

## Get trial data
# Update test participant ID
trial_ids = ['katie'] 
# Update filepath with participant ID 
getTrialData('Trials', 100, '/Users/katie/Documents/1-Product/Research/OnPoint-Music-Admin-and-Data/data_storage/trials_raw/katie.csv', trial_ids, db)
